# 线程池在springboot优雅使用

1. 自定义线程工厂

```java
/**
 * 创建线程工厂
 */
@Slf4j
public class CustomThreadFactory implements java.util.concurrent.ThreadFactory {
    private final AtomicInteger threadNumber = new AtomicInteger(1);
    private final String namePrefix;

    public CustomThreadFactory(String namePrefix) {
        this.namePrefix = namePrefix;
    }

    @Override
    public Thread newThread(Runnable r) {
        String threadName = namePrefix + threadNumber.getAndIncrement();
        Thread thread = new Thread(r, threadName);

        // 设置异常处理器
        thread.setUncaughtExceptionHandler((t, e) -> {
            log.error("线程 {} 执行中出现未捕获异常: {}", t.getName(), e.getMessage(), e);
        });

        log.info("创建新线程: {}", threadName);
        return thread;

    }
}
```

2. 自定义拒接策列

```java
/**
 * 自定义线程拒接策略
 */
@Slf4j
public class CustomRejectedExecutionHandler implements java.util.concurrent.RejectedExecutionHandler {
    @Override
    public void rejectedExecution(Runnable r, ThreadPoolExecutor executor) {
        // 记录拒绝的任务信息
        log.warn("任务被线程池拒绝: {}", r.toString());
        log.warn("线程池状态: 活跃线程数={}, 核心线程数={}, 最大线程数={}, 队列大小={}, 已完成任务数={}",
                executor.getActiveCount(),
                executor.getCorePoolSize(),
                executor.getMaximumPoolSize(),
                executor.getQueue().size(),
                executor.getCompletedTaskCount());

        // 根据业务需求可以选择不同的处理策略:
        // 1. 抛出异常
        // 2.todo 队列阻塞在这里编写
        throw new RejectedExecutionException("任务 " + r.toString() + " 被线程池拒绝");

    }
}

```



3. 自定义线程池配置类

```java
/**
 * 自定义线程池配置类
 */
@Configuration
public class CustomThreadPoolConfig {
    @Value("${thread.pool.core.size:5}")
    private int corePoolSize;

    @Value("${thread.pool.max.size:10}")
    private int maxPoolSize;

    @Value("${thread.pool.keep.alive.seconds:60}")
    private long keepAliveSeconds;

    @Value("${thread.pool.queue.capacity:100}")
    private int queueCapacity;

    @Value("${thread.pool.await.termination.seconds:30}")
    private int awaitTerminationSeconds;

    /**
     * 创建通用线程池
     */
    @Bean("testThreadPool")
    public ThreadPoolExecutor testThreadPool() {
        // 使用自定义线程工厂和拒绝策略
        ThreadPoolExecutor executor = new ThreadPoolExecutor(
                corePoolSize,
                maxPoolSize,
                keepAliveSeconds,
                TimeUnit.SECONDS,
                new LinkedBlockingQueue<>(queueCapacity),
                new CustomThreadFactory("test-pool"),
                new CustomRejectedExecutionHandler());

        return executor;
    }
    /**
     * 创建IO密集型任务线程池
     */

    /**
     * 创建CPU密集型任务线程池
     */

}
```

4. 自定义线程管理器

```java

/**
 * 自定义线程管理器
 */
@Slf4j
@Component
public class ThreadPoolManager {
    private final ThreadPoolExecutor testThreadPool;
    // 可以放map来进行管理
//    private final Map<String, ThreadPoolExecutor> threadPoolMap = new ConcurrentHashMap<>();



    public ThreadPoolManager(@Qualifier("testThreadPool")ThreadPoolExecutor testThreadPool) {
        this.testThreadPool = testThreadPool;
        //******************** 线程池是按需创建线程的，这个方法可以一次性创建所有核心线程 ***************************
        this.testThreadPool.prestartAllCoreThreads();
    }

    @PostConstruct
    public void init() {
        // 注册所有线程池
//        threadPoolMap.put("test", testThreadPool);
//        log.info("线程池管理器初始化完成，已注册 {} 个线程池", threadPoolMap.size());
    }

    /**
     * 提交任务到指定线程池
     */
    public void submitTest(Runnable task) {
        testThreadPool.execute(task);
    }


    /**
     * 优雅关闭所有线程池
     */
    @PreDestroy
    public void shutdown() {
        testThreadPool.shutdownNow();
    }
}
```

5. 使用

```java
    @GetMapping("/testThread")
    public String testThread() {
        CompletableFuture<String> future = new CompletableFuture<>();
        
        threadPoolManager.submitTest(() ->{
            log.info("111");
            future.complete("success");
        });
        try {
            future.get();

        } catch (InterruptedException e) {
            throw new RuntimeException(e);
        } catch (ExecutionException e) {
            throw new RuntimeException(e);
        }
        return "success";

    }
```



